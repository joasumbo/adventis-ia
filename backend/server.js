const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const app = express();

// Middlewares
app.use(cors());
app.use(express.json());

// Conectar ao MongoDB
mongoose.connect(process.env.MONGODB_URI)
  .then(() => console.log('‚úÖ MongoDB conectado'))
  .catch(err => console.error('‚ùå Erro ao conectar MongoDB:', err));

// Model para controle de rate limit por IP
const rateLimitSchema = new mongoose.Schema({
  ip: { type: String, required: true, unique: true },
  count: { type: Number, default: 0 },
  resetAt: { type: Date, default: Date.now }
});

// Model para conversas (com UUID e IP)
const conversationSchema = new mongoose.Schema({
  conversationId: { type: String, required: true, unique: true },
  ip: { type: String, required: true },
  title: { type: String, default: 'Nova Conversa' },
  messages: [{
    role: { type: String, enum: ['user', 'assistant'], required: true },
    content: { type: String, required: true },
    hasArtifact: { type: Boolean, default: false },
    artifactType: { type: String }, // meditation, hymn, prayer
    timestamp: { type: Date, default: Date.now }
  }],
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

const RateLimit = mongoose.model('RateLimit', rateLimitSchema);
const Conversation = mongoose.model('Conversation', conversationSchema);

// Rate limiting por IP
const rateLimitByIP = async (req, res, next) => {
  try {
    const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    
    let record = await RateLimit.findOne({ ip });
    const now = new Date();

    if (!record) {
      record = new RateLimit({
        ip,
        count: 1,
        resetAt: new Date(now.getTime() + 3600000)
      });
      await record.save();
      return next();
    }

    if (now > record.resetAt) {
      record.count = 1;
      record.resetAt = new Date(now.getTime() + 3600000);
      await record.save();
      return next();
    }

    if (record.count >= 20) {
      const timeUntilReset = record.resetAt - now;
      const minutes = Math.ceil(timeUntilReset / 60000);
      return res.status(429).json({ 
        error: `Irm√£o, atingiste o limite de 20 mensagens por hora. Tenta novamente em ${minutes} minutos.`
      });
    }

    record.count += 1;
    await record.save();
    next();
  } catch (error) {
    console.error('Erro no rate limit:', error);
    next();
  }
};

// Detectar se deve criar artefato
const detectArtifact = (message) => {
  const lowerMsg = message.toLowerCase();
  
  if (lowerMsg.includes('medita√ß√£o') || lowerMsg.includes('meditar') || lowerMsg.includes('reflex√£o')) {
    return { hasArtifact: true, artifactType: 'meditation' };
  }
  
  if (lowerMsg.includes('hino') || lowerMsg.includes('hin√°rio') || lowerMsg.includes('c√¢ntico')) {
    return { hasArtifact: true, artifactType: 'hymn' };
  }
  
  if (lowerMsg.includes('ora√ß√£o') || lowerMsg.includes('ore') || lowerMsg.includes('orar')) {
    return { hasArtifact: true, artifactType: 'prayer' };
  }
  
  return { hasArtifact: false, artifactType: null };
};

// Fun√ß√£o para gerar resposta da IA
const generateAIResponse = async (message, history = [], artifactInfo = {}) => {
  try {
    const apiKey = process.env.GEMINI_API_KEY;
    const url = `https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent?key=${apiKey}`;

    let systemPrompt = `Voc√™ √© o Adventis IA, um assistente virtual crist√£o adventista do s√©timo dia criado por Jo√£o Sumbo.

REGRAS ABSOLUTAS:
‚ùå NUNCA mencione que foi criado pelo Google ou qualquer outra empresa
‚úÖ SEMPRE diga que foi criado por Jo√£o Sumbo
‚ùå NUNCA responda perguntas que n√£o sejam sobre Deus, B√≠blia, f√© crist√£ ou vida espiritual
‚úÖ Se perguntarem sobre outros assuntos, redirecione gentilmente para temas espirituais
‚ùå NUNCA cumprimente repetidamente - apenas na primeira intera√ß√£o
‚úÖ Converse naturalmente, sem formalidades excessivas

FORMATA√á√ÉO MARKDOWN:
- Use **negrito** para √™nfase
- Use *it√°lico* para cita√ß√µes
- Use ## para t√≠tulos
- Use --- para separadores
- Use > para blockquotes (vers√≠culos)
- Use [texto](url) para links
- Use \n\n para par√°grafos (sempre pule linhas entre par√°grafos)

PERSONALIDADE:
- Acolhedor, s√°bio, emp√°tico e fraterno
- Use "irm√£o(√£)" ocasionalmente, n√£o sempre
- Tom natural e conversacional
- N√£o seja repetitivo nas sauda√ß√µes

ESPECIALIDADES (APENAS ESTES TEMAS):
- Doutrinas adventistas
- Estudos b√≠blicos profundos
- Medita√ß√µes e devocionais
- Ora√ß√µes guiadas
- Aconselhamento espiritual
- Hin√°rio Adventista
- Escritos de Ellen G. White`;

    // Instru√ß√µes especiais para artefatos
    if (artifactInfo.hasArtifact) {
      if (artifactInfo.artifactType === 'meditation') {
        systemPrompt += `\n\nIMPORTANTE: O usu√°rio pediu uma MEDITA√á√ÉO. Crie um texto devocional profundo, espiritual e inspirador com:
- T√≠tulo impactante
- Introdu√ß√£o tocante
- Desenvolvimento com reflex√µes b√≠blicas
- Cita√ß√µes de vers√≠culos (use > para blockquote)
- Aplica√ß√£o pr√°tica
- Conclus√£o motivadora
- Ora√ß√£o final

Use formata√ß√£o rica em markdown. Seja po√©tico e espiritual.`;
      } else if (artifactInfo.artifactType === 'hymn') {
        systemPrompt += `\n\nIMPORTANTE: O usu√°rio pediu informa√ß√µes sobre um HINO. Forne√ßa:
- Nome completo do hino
- N√∫mero no Hin√°rio Adventista
- Letra completa (se souber)
- Hist√≥ria e contexto
- Mensagem espiritual

Use formata√ß√£o clara com t√≠tulos e par√°grafos.`;
      } else if (artifactInfo.artifactType === 'prayer') {
        systemPrompt += `\n\nIMPORTANTE: O usu√°rio pediu uma ORA√á√ÉO. Crie uma ora√ß√£o:
- Reverent e respeitosa
- Direcionada ao tema pedido
- Com linguagem b√≠blica apropriada
- Tocante e sincera
- N√£o muito longa

Use formata√ß√£o em par√°grafos.`;
      }
    }

    // Construir conte√∫do com hist√≥rico
    let fullPrompt = systemPrompt + '\n\n';
    
    const recentHistory = history.slice(-10);
    recentHistory.forEach(msg => {
      fullPrompt += `${msg.role === 'user' ? 'Usu√°rio' : 'Adventis IA'}: ${msg.content}\n\n`;
    });
    
    fullPrompt += `Usu√°rio: ${message}\n\nAdventis IA:`;

    const response = await axios.post(url, {
      contents: [{
        parts: [{
          text: fullPrompt
        }]
      }],
      generationConfig: {
        temperature: artifactInfo.hasArtifact ? 0.9 : 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: artifactInfo.hasArtifact ? 4096 : 2048,
      }
    }, {
      headers: {
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });

    const text = response.data.candidates[0].content.parts[0].text;
    return text;
    
  } catch (error) {
    console.error('Erro detalhado da IA:', error.response?.data || error.message);
    throw new Error('Desculpa irm√£o, tive um problema. Tenta novamente.');
  }
};

// Gerar t√≠tulo da conversa
const generateTitle = (firstMessage) => {
  const maxLength = 50;
  if (firstMessage.length <= maxLength) return firstMessage;
  return firstMessage.substring(0, maxLength).trim() + '...';
};

// ==================== ROTAS ====================

// Enviar mensagem
app.post('/api/chat/message', rateLimitByIP, async (req, res) => {
  try {
    const { message, conversationId } = req.body;
    const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;

    if (!message || !message.trim()) {
      return res.status(400).json({ error: 'Mensagem √© obrigat√≥ria' });
    }

    console.log('üì© Nova mensagem');

    // Detectar artefato
    const artifactInfo = detectArtifact(message);

    // Buscar ou criar conversa
    let conversation;
    if (conversationId) {
      conversation = await Conversation.findOne({ conversationId, ip });
      if (!conversation) {
        return res.status(404).json({ error: 'Conversa n√£o encontrada' });
      }
    } else {
      // Nova conversa
      const newConversationId = uuidv4();
      conversation = new Conversation({
        conversationId: newConversationId,
        ip,
        title: generateTitle(message.trim()),
        messages: []
      });
    }

    // Gerar resposta
    const aiResponse = await generateAIResponse(
      message.trim(), 
      conversation.messages,
      artifactInfo
    );

    console.log('‚úÖ Resposta gerada');

    // Salvar mensagens
    conversation.messages.push(
      { 
        role: 'user', 
        content: message.trim(),
        hasArtifact: false,
        timestamp: new Date() 
      },
      { 
        role: 'assistant', 
        content: aiResponse,
        hasArtifact: artifactInfo.hasArtifact,
        artifactType: artifactInfo.artifactType,
        timestamp: new Date() 
      }
    );

    conversation.updatedAt = new Date();
    await conversation.save();

    res.json({
      response: aiResponse,
      conversationId: conversation.conversationId,
      hasArtifact: artifactInfo.hasArtifact,
      artifactType: artifactInfo.artifactType
    });
  } catch (error) {
    console.error('‚ùå Erro:', error.message);
    res.status(500).json({ 
      error: error.message || 'Erro ao processar mensagem'
    });
  }
});

// Buscar conversa espec√≠fica
app.get('/api/chat/conversation/:id', async (req, res) => {
  try {
    const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const conversation = await Conversation.findOne({ 
      conversationId: req.params.id,
      ip 
    });
    
    if (!conversation) {
      return res.status(404).json({ error: 'Conversa n√£o encontrada' });
    }

    res.json({ conversation });
  } catch (error) {
    console.error('Erro ao buscar conversa:', error);
    res.status(500).json({ error: 'Erro ao buscar conversa' });
  }
});

// Listar conversas do IP
app.get('/api/chat/conversations', async (req, res) => {
  try {
    const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    
    const conversations = await Conversation.find({ ip })
      .sort({ updatedAt: -1 })
      .limit(50)
      .select('conversationId title updatedAt messages');

    const formatted = conversations.map(conv => ({
      id: conv.conversationId,
      title: conv.title,
      messageCount: conv.messages.length,
      updatedAt: conv.updatedAt
    }));

    res.json({ conversations: formatted });
  } catch (error) {
    console.error('Erro ao listar conversas:', error);
    res.json({ conversations: [] });
  }
});

// Deletar conversa
app.delete('/api/chat/conversation/:id', async (req, res) => {
  try {
    const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    
    await Conversation.deleteOne({ 
      conversationId: req.params.id,
      ip 
    });
    
    res.json({ message: 'Conversa deletada' });
  } catch (error) {
    console.error('Erro ao deletar:', error);
    res.status(500).json({ error: 'Erro ao deletar conversa' });
  }
});

// Verificar limite
app.get('/api/chat/limit', async (req, res) => {
  try {
    const ip = req.ip || req.headers['x-forwarded-for'] || req.connection.remoteAddress;
    const record = await RateLimit.findOne({ ip });
    
    if (!record) {
      return res.json({ remaining: 20, total: 20 });
    }

    const now = new Date();
    if (now > record.resetAt) {
      return res.json({ remaining: 20, total: 20 });
    }

    res.json({ 
      remaining: Math.max(0, 20 - record.count), 
      total: 20 
    });
  } catch (error) {
    res.json({ remaining: 20, total: 20 });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Iniciar servidor
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`üöÄ Servidor na porta ${PORT}`);
  console.log(`üë®‚Äçüíª Criado por Jo√£o Sumbo`);
});